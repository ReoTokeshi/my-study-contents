
Stringのプールと似たような仕組みで、ラッパークラスのキャッシュがある。ラッパークラスの一部は、頻出する小さい値をキャッシュしてメモリ節約・高速化。<br>
ただし`new Integer(100)`のように生成した場合に限っては必ず別のオブジェクト作られる。これはStringと同じ。

| クラス | キャッシュ範囲 |
| --- | --- |
| Byte, Short, Integer, Long | -128～127 |
| Character | 0～127 |
| Boolean | true / false |
|  |  |

## １章　Java概要

同じファイル内に複数クラス書く場合、１クラスだけ`public class`指定可（指定しなくてもOK）。<br>
指定したら、ファイル名をそのpublicクラスと同じ名前にする（mainメソッド有無は関係なし）

◆コンパイル

`javac -d (クラスファイル生成場所) (ソース名)`でパッケージのディレクトリ構成を生成してコンパイル（クラスファイル生成）

◆実行

実行時は完全修飾クラス名（FQCN）を指定。パッケージ構成通りに**クラスファイル**を配置する。

`java ~.java`でソースファイルモード実行。クラスファイル作成されない（メモリ上で実行）

クラスパス指定`-cp`について。<br>
デフォルトだとカレントディレクトリを起点（ルート）としてパッケージ構成をたどるが、<br>
-cp付けると起点（ルート）を好きに指定して実行できる。<br>
`例）java -cp ..\classes com.se.Main`<br>
`　　指定しなければカレントclassesからjava com.se.Main`

## ２章　基本データ型と文字列操作

ローカル変数は型によらず、自分で初期化が必要。使う前に初期化してるか、初期化してなくても使わなければOK。初期化せず使うとコンパイルエラー。フィールドは暗黙で自動初期化されるので、必須ではない。

変数宣言を１文で行うルール。<br>
データ型は１度のみ記載。変数宣言のみと、初期化まで行う記述混ざっててもOK。　<br>
`例）float f1, f2 = 3.1415F;`  
配列の型の書き方は結構自由。  
１次元：`int[] a`、`int a[]`  
２次元：`int[][] a`、`int a[][]`、`int[] a[]`

配列宣言。newして同時に初期化なら、要素数は書かないこと。  
`int[] a = new int[3];`  
`int[] a = new int[]{10, 20, 30};　←OK。int[3]だとエラー`<br>
配列リテラル（newなしの初期化）は、配列宣言と同時にしか使えない。既存変数へ代入はダメ。  
`a = {10, 20, 30};　←これはエラー`

２次元配列は１次元目の要素数は必須。２次元目は書かないと要素数０。<br>
`int[][] a = new int[][3];　←エラー`  
２次元目でそれぞれ要素数を変えることも可能（ジャグ配列）。<br>
`int[][] a = new int[][]{{10}, {10, 20}, {10, 20, 30}};`  

varは配列にも使える。ただし、宣言時に型が分かるときだけ。  
`var a = {1, 2, 3}; ←これはエラー。右辺を配列リテラルだけだとNG。`  
（var[]じゃないことに注意）

- テキストブロック

開始「"""」の直後に文字列NG。終了「"""」直前は文字列OK。<br>
ダブルクォーテーションはそのまま「"」か、３連続のときは「\\"""」。<br>
末尾に「\\」で改行がエスケープされ結果が改行されなくなる。<br>
末尾にスペース入れるときはスペースうしろに「\\s」入れる。これでもスペース１個分。

- StringBuilder （可変文字列）

末尾へ追加はappend、間への挿入はinsert。  
deleteやreplaceやsubstringは開始～終了のインデックスを指定する。  

substringは戻り値がStringで元のオブジェクトは変更されないので、使うときはString型変数に代入する。

StringBuilderには等価性を判断するequals()は用意されてないので、toStringでString型にしてからequalsを使って比較する。

### リテラルの範囲

| データ型 | サイズ | 大体の範囲 | 
| --- | --- | --- |
| byte | 8ビット | -128～127 |
| short | 16ビット | 32_000　(-32768～32767) |
| int | 32ビット | 2_100_000_000　(-2147483648～2147483647) |
| long | 64ビット | intより大きい |
|  |  |

`2_200_000_000` ←これだけでコンパイルエラー。これ自体がintリテラルだが範囲超えているため。

char型は特殊文字もOK。'\n'とか'\"'

## ３章　演算子と条件分岐

基本、大きい型から小さい型へはキャストが必要。収まる範囲であれば不要（あってもOK）。  
`byte a = 97;`もしくは`byte a = (byte)97;`<br>
ただし演算結果の代入では・・  
　定数どうし　　　　⇒計算時に値が確定しているので<u>**キャスト不要**</u>  
　　`short s1 = 1 + 2; ←OK`  
　<u>変数が入った演算</u>　⇒（byte/short/char）の演算は常にint型に昇格されるので、<u>**キャスト必要**</u>  
　　`short s1 = 1; short s2 = s1 + 2; ←これはエラー。キャストするか、int型を用意する。`

char → 数値型（byte / short）へはキャストが必要。  
それ以外（int / long / float / double）への変換はキャスト不要。
`例）char a = 'd'; byte b = (byte)a;`<br>
アルファベット「d」の10進数表記は「100」。これだけ覚えてあとは増減させる。

ラッパークラスでは  
・対応するクラスへはボクシングされる。  
　　`Integer a = 10; ⇒オートボクシング`  
　　`int b = a; ⇒オートアンボクシング`  
・基本データ型のような暗黙的な型変換はされないので注意。  
　　`Double d = 10; ⇒コンパイルエラー`

---
### Stringオブジェクトの同一性と等価性

（紫本 問題3-8, 3-9）  
- 文字列リテラルで生成したStringはプールで管理される。
コンパイル時に同じリテラルが作成されたら、すでにプールにあるオブジェクトを参照する。
（つまり、変数経由とかで作成したら新しく生成されて別参照になる）
- intern()メソッドは文字列の内容をみて、プールにあればその参照を返す。  

例）  
`String s = "java";`

`String j = "j";`  
`String s1 = j + "ava";`  
　⇒これはコンパイル時に確定しないため新しく生成されるので、sとは別の参照になる。  
`String s2 = (j + "ava").intern(); `  
　⇒こうすると同じ内容の文字列"java"がプールにあるので、sと同じ参照になる。

- <u>StringBuilderで作る文字列はStringとは完全別物として考える。</u>つまり・・  
  -  toString使っても新しく生成される
  -  Stringクラスのequalsの引数はString型以外の場合はfalseにするので、StringBuilderとの内容比較には使えない。

---

### switch文・switch式

defaultの記載は、switch文なら任意、**switch式なら必須**(必ず値を返す必要があるため)。

defaultとcaseの記載順は関係なく、上から順に評価実行されていく。  
break書かないと、<u>一致したcaseから下まですべて実行される（フォールスルー）</u>。  
`->`使えば、一致したcaseだけ実行されるのでbreak文が不要。

switch()内に指定できるのはbyte、short、int、char、String、enum(試験外)と、該当のラッパークラスのみ(longやfloat、doubleはダメ)。null指定すると例外NullPointerException。  

case値は定数のみOK。変数の場合はコンパイル時定数※であればOK
（※finalで宣言と同時に初期化）  
switch(式)に指定したものと同じデータ型である必要あり。  
例）  
このcase値は計算結果はint型だが、  
定数同士の計算でかつcharの範囲内（0〜65535）なのでOK。
```java
switch("java".charAt(0)){
   case 'a' + 106:　
      ～処理～
}
```


switch式は、  
`:` を使うとき・・ `yield(イールド)`で値を戻す(returnではない)。  
`->`を使うとき・・ 戻す値だけそのまま書ける。ただし複数処理を書いたときだけ`yield(イールド)`使う。

## ６章　継承とインタフェース

親クラスと子クラスで同名フィールド定義すると、親クラス側が隠蔽される（アクセス修飾子は関係なし）。アクセスにはsuper.か、親クラスの型で参照。<br>
親クラスにgetterがある場合、子クラスでオーバーライドしてなければ、親クラスのフィールドが返される。

コンストラクタ内で別のコンストラクタ呼ぶとき、最初の行でかつsuper(…)かthis(…)どちらか１回呼べる。両方は呼べない。<br>
this(…)のときは必ず別のコンストラクタ。自分自身を呼ぶとコンパイルエラー。

### インタフェース

インタフェース同士は複数継承OK。`例）interface A extends B, C {}`<br>
通常クラスは複数実装OK。`例）class A implements B, C {}`

 - defaultメソッド

複数実装でdefaultメソッドが衝突(シグネチャ一致)した場合はオーバーライド必要。<br>
なので、<u>**両メソッドの戻り値の型に互換性※がないとオーバーライドでまとめられない**</u>ので、その場合は複数実装不可。互換性ある場合は、より具体的な方の型に戻り値を統一（Object vs Stringなら<u>String</u>、Number vs Integerなら<u>Number</u>）。
<br>（※互換性：参照型で継承関係あり）

オーバーライド後、どちらかのメソッドを呼び出したいときは`継承元インタフェース名.super.メソッド名()`でアクセス。１階層上のみ。

 - フィールド

・暗黙で`public static final`がつく。なので初期化必須。<br>
・アクセスには`インタフェース名.変数名`か`参照変数.変数名`、実装していれば`変数名`そのままでもアクセス可能。

 - staticメソッド

インタフェースのstaticメソッドは`インタフェース名.メソッド名()`でのみ呼び出せる。参照変数からは呼べない。実装クラスだったとしても`メソッド名()`ではアクセスできない。<br>
（普通のクラスは参照変数からも呼べるし、継承先だとそのままメソッド名で呼べる）

---

### シールクラス

クラスにもインタフェースにも`sealed`つけられる。<br>
インタフェースにつけた場合、permits指定先はクラス・インタフェースどちらでもOK（クラスには実装を強制、インタフェースには継承を強制）。


permitsにレコードクラス指定不可（レコードクラスはクラスの継承できないので）。

`non-sealed`指定するときは、シールクラスをextendsか、シールインタフェースをimplementsが必要。

`sealed class`順番に注意。

`sealed`指定時、同じソースファイル内のクラスを指定する場合はpermits省略可能。<br>
　⇒つまり、指定必須ではない

---

### レコードクラス

暗黙的にjava.lang.Recordクラスを継承するため、レコードクラスは他のクラスを継承不可（インタフェースの実装は可）。また、暗黙で`final`なので普通のクラスもレコードクラスは継承不可。

普通のクラスと同様、publicかパッケージプライベート。

`「record」`はクラス名、レコード名、インタフェース名に使用不可（ 「Record」はOK）。ただし変数名には使える。

**・標準コンストラクタ**
<br>　⇒通常の書き方。コンポーネントと引数を完全一致（型、数、順番）させる。`this.`を使ってコンポーネントを初期化。<br>
**・コンパクトコンストラクタ**
<br>　⇒引数を省略して、書きたい初期化だけ実装。<u>`this.`は使わない！</u>

---

### パターンマッチング

パターン変数のスコープは<u>**パターンに確実にマッチする範囲**</u>（ローカル変数とは異なる）。マッチしていることが確定していれば｛｝外でもOK。`if(obj instanceof String s && `<u>`s.length == 3`</u>`) {}`みたいな短絡評価での使い方でも、評価時にマッチ確定しているのでOK（この場合&や||だとNG）。

---

### コレクション

- ジェネリクスについて

・内部処理のKとかVは、コレクション生成時に具体的に型が決まる！<br>（HashMap<Number, String>なら、K→Number、V→String）<br>
・コレクション生成時、中身を書かないダイヤモンド演算子<>は右辺だけOK。左辺<…>の中身は省略できない！<br>
・両方に書く場合は、必ず同じ型にする。<br>
・<…>そのものを省略の場合、要素はObject型になる。
　`例）ArrayList list = new ArrayList();`

- ArrayList

|メソッド定義|内容|
| ---- | ---- |
| boolean add(E e) | trueを返す |
| E remove(int idx) | 削除した要素を返す |
| boolean remove(Object o) | trueを返す(消す要素内容は指定してるからね) |
| E set(int idx, E e) | 置き換え前の要素を返す |
|  |  |

- HashSet

・数学の集合のイメージ。重複不可。<br>
・メソッド名は基本ArrayListと同じ。
・toString()は[20, 10, 30]のように出力。順不同。

- HashMap

・Key-Valueで管理。Keyは重複不可。<br>
・要素追加するメソッドはput（addではない！）<br>
・toString()は{DE=Germany, UK=United Kingdom, FR=France}のように出力。順不同。

|メソッド定義|内容|
| ---- | ---- |
| V put(K key, V value) | キーが既にある場合は置き換え前の値を返す |
| V removed(Object key) | 削除した要素の値を返す |
| Set<K> keySet() | キー一覧をSetで返す（重複ないから） |
| Collection<V> values() | 値一覧をCollectionで返す（重複あるかもだから） |
|  |  |

- 配列⇒リストの生成

・Arraysクラスの`static <T> List<T> asList(T... a)`を使用する。戻り値はList型のため、ArrayList型に入れられないことに注意。作られたListは固定サイズなので、追加や削除など要素数が変わる操作は<u>UnsupportedOperationException</u>になる。(List型なのでコンパイルはできるが…)

・List, Map, Setインタフェースの`static <E> List<E> of(E... elements)`を使用する。これは完全にイミュータブル（変更不可）なので、いかなる変更も<u>UnsupportedOperationException</u>になる。

---

### ★　オーバーライドの条件

- メソッドのシグネチャ（メソッド名、引数リスト）：同一<br>
（引数の数、順番、<u>**型も完全一致！**</u>）

- 戻り値の型：同一、または、サブクラスの型でもOK

- アクセス修飾子：同一、または、より公開範囲の広いもの

- staticメソッドはクラスに属すためオーバーライドできない（隠ぺい）<br>
privateメソッドも、継承されないのでオーバーライドできない。

- throws指定：同一、または、サブクラスの例外を指定。あるいは省略か非チェック例外の追加。

### ★　オーバーロードの条件

- メソッド名は同一。引数の数、型、順番どれかを変えれば成立。

- 戻り値の有無（voidか、その他か）と、アクセス修飾子は関係なし<br>
<u>**⇒つまり、これだけ変えてもオーバーロードにならない！**</u>

## ７章　例外処理

Exception以下のクラスは・・<br>
・**RuntimeExceptionとそのサブクラス**は非チェック例外。<br>
・それ以外はすべてチェック例外

メソッド定義においてチェック例外クラスをthrowsに指定した場合、<u>実際にthrow処理書いてなくても</u>、呼び出し側ではcatch処理が必須。ないとコンパイルエラー。

throwsには、実際にthrowするもののスーパークラスを指定可。ただし、呼び出し側のcatchにはそのthrows指定クラス以上しか指定できない（ダウンキャストされないから）。

throws指定したメソッドのオーバーライドは、<u>**呼び出し元でキャッチできる範囲でthrowsの変更が可能！**</u><br>(省略か非チェック例外追加か、または同じ例外クラスかそのサブクラスか)

- multi-catch

以下の２つはコンパイルエラー。

・継承関係のある例外クラスを書く<br>
   `例）catch(IOException | Exception e) {}`<br>
・例外変数の再代入　（通常のcatchは可能）


- try-with-resources

try()内に書けるリソースは`AutoCloseable`インタフェース実装したものじゃないとコンパイルエラー（CloseableもOK。実装しているので）。

varによる型推論が可能。ただしcatchの()内ではダメ。<br>
`例）try(var fw = new FileWriter("AAA.txt")) {}`<br>

try()の前で生成したリソースオブジェクトの指定も可能。try(fw)

tryブロックのみの定義が可能（普通のtry文ではcatchかfinally必須）。

try()で指定した変数は暗黙的にfinalとなるため、再代入は不可。

例外発生してもしなくても、close()はtry終了直後に行われる。catchやfinallyの処理はそのあと。<br>
なお、リソースを複数書いた場合は、書いた逆順でcloseされる。<br>
`例）try(fw1; fw2) {} はfw2⇒fw1の順`

ちなみに・・・<br>
close() の中で例外が発生した場合でも、他のリソースのclose()は続行。
複数のclose()で例外が出た場合、  <u>**最初の例外がスロー**</u>され、後続は「抑制された例外（Suppressed Exception）」 として保持される。